"""
Gaussian Channel Strategy Module for ZT-3 Trading System.

This module implements the Gaussian Channel trading strategy, which uses
a Gaussian filter for generating entry and exit signals.
"""

import logging
import pandas as pd
import numpy as np
from typing import Dict, List, Any, Union, Optional, Tuple
from datetime import datetime
from enum import Enum

from strategy.indicators import Indicators

logger = logging.getLogger(__name__)

class SignalType(Enum):
    """Signal types for trading strategies."""
    ENTRY = "ENTRY"
    EXIT = "EXIT"
    NONE = "NONE"

class ExitReason(Enum):
    """Reasons for exit signals."""
    STOP_LOSS = "STOP_LOSS"
    TAKE_PROFIT = "TAKE_PROFIT"
    TRAILING_STOP = "TRAILING_STOP"
    SIGNAL_CHANGE = "SIGNAL_CHANGE"
    TIME_LIMIT = "TIME_LIMIT"  # Time-based exit
    CUSTOM = "CUSTOM"

class Signal:
    """
    Trading signal generated by a strategy.
    
    Attributes:
        timestamp: Time when the signal was generated
        symbol: Trading symbol
        signal_type: Type of signal (entry, exit)
        price: Price at which the signal was generated
        direction: Long or short
        stop_loss_level: Price level for stop loss
        take_profit_level: Price level for take profit
        exit_reason: Reason for exit (only for exit signals)
        metadata: Additional data for the signal
    """
    
    def __init__(
        self, 
        timestamp: datetime,
        symbol: str,
        signal_type: SignalType,
        price: float,
        direction: str = "LONG",
        stop_loss_level: Optional[float] = None,
        take_profit_level: Optional[float] = None,
        exit_reason: Optional[ExitReason] = None,
        metadata: Optional[Dict[str, Any]] = None
    ):
        """
        Initialize a new trading signal.
        
        Args:
            timestamp: Time when the signal was generated
            symbol: Trading symbol
            signal_type: Type of signal (entry, exit)
            price: Price at which the signal was generated
            direction: Trade direction (LONG or SHORT)
            stop_loss_level: Price level for stop loss
            take_profit_level: Price level for take profit
            exit_reason: Reason for exit (only for exit signals)
            metadata: Additional data for the signal
        """
        self.timestamp = timestamp
        self.symbol = symbol
        self.signal_type = signal_type
        self.price = price
        self.direction = direction
        self.stop_loss_level = stop_loss_level
        self.take_profit_level = take_profit_level
        self.exit_reason = exit_reason
        self.metadata = metadata or {}
        
    def __str__(self) -> str:
        """String representation of the signal."""
        base_str = (f"Signal({self.symbol}, {self.signal_type.value}, "
                  f"Price: {self.price:.2f}, Direction: {self.direction}")
                  
        if self.stop_loss_level is not None:
            base_str += f", SL: {self.stop_loss_level:.2f}"
            
        if self.take_profit_level is not None:
            base_str += f", TP: {self.take_profit_level:.2f}"
            
        if self.exit_reason is not None:
            base_str += f", Reason: {self.exit_reason.value}"
            
        base_str += ")"
        return base_str

class GaussianChannelStrategy:
    """
    Gaussian Channel trading strategy.
    
    This strategy uses a Gaussian filter for market trend direction 
    in combination with StochasticRSI for entry timing.
    """
    
    def __init__(self, config: Dict[str, Any]):
        """
        Initialize the Gaussian Channel strategy.
        
        Args:
            config: Strategy configuration
        """
        self.config = config
        self.strategy_config = config.get('strategy', {})
        self.params = self.strategy_config.get('params', {})
        
        # Extract channel parameters
        gc_params = self.params.get('gaussian_channel', {})
        self.gc_period = gc_params.get('period', 144)
        self.gc_multiplier = gc_params.get('multiplier', 1.2)
        
        # Extract StochasticRSI parameters
        stoch_params = self.params.get('stochastic_rsi', {})
        self.stoch_k_overbought = stoch_params.get('k_overbought', 80)
        self.stoch_k_oversold = stoch_params.get('k_oversold', 20)
        
        # Extract risk management parameters
        risk_params = config.get('risk', {}).get('params', {})
        self.stop_loss_atr_multiplier = risk_params.get('stop_loss_atr_multiplier', 1.5)
        self.take_profit_atr_multiplier = risk_params.get('take_profit_atr_multiplier', 2.5)
        
        # Trade direction
        self.trade_direction = self.strategy_config.get('direction', 'BOTH').upper()
        
        logger.info(f"Initialized Gaussian Channel Strategy with period={self.gc_period}, multiplier={self.gc_multiplier}")
        
    def generate_signals(self, df: pd.DataFrame, symbol: str) -> Tuple[pd.DataFrame, List[Signal]]:
        """
        Generate trading signals based on the strategy.
        
        Args:
            df: DataFrame with price data and indicators
            symbol: Trading symbol
            
        Returns:
            Tuple of (DataFrame with signals, List of Signal objects)
        """
        if len(df) < self.gc_period + 10:  # Need enough data for reliable signals
            logger.warning(f"Not enough data for {symbol} to generate reliable signals")
            return df.copy(), []
            
        # Add indicators if they are not already in the DataFrame
        required_columns = ['gc_filter', 'gc_upper', 'gc_lower', 'stoch_rsi_k', 'stoch_rsi_d', 'atr']
        if not all(col in df.columns for col in required_columns):
            df = Indicators.add_all_indicators(df, self.config)
            
        # Create a copy of the DataFrame for signal generation
        result = df.copy()
        
        # Initialize signal columns
        result['signal'] = 0  # 0: no signal, 1: buy signal, -1: sell signal
        result['signal_type'] = None
        result['stop_loss'] = None
        result['take_profit'] = None
        
        # Generate signals based on Gaussian Channel and StochasticRSI
        signals = []
        
        for i in range(1, len(result)):
            # Skip rows with NaN values in indicators
            if (pd.isna(result.iloc[i]['gc_filter']) or 
                pd.isna(result.iloc[i]['stoch_rsi_k']) or 
                pd.isna(result.iloc[i]['atr'])):
                continue
                
            # Get current and previous values
            curr_close = result.iloc[i]['close']
            curr_gc_filter = result.iloc[i]['gc_filter']
            curr_gc_upper = result.iloc[i]['gc_upper']
            curr_gc_lower = result.iloc[i]['gc_lower']
            curr_stoch_k = result.iloc[i]['stoch_rsi_k']
            curr_stoch_d = result.iloc[i]['stoch_rsi_d']
            curr_atr = result.iloc[i]['atr']
            
            prev_close = result.iloc[i-1]['close']
            prev_gc_filter = result.iloc[i-1]['gc_filter']
            prev_stoch_k = result.iloc[i-1]['stoch_rsi_k']
            prev_stoch_d = result.iloc[i-1]['stoch_rsi_d']
            
            # Entry conditions
            # Long: Price above filter, StochasticRSI K line crosses D line from below
            long_condition = (
                (self.trade_direction in ['BOTH', 'LONG']) and
                (curr_close > curr_gc_filter) and
                (prev_stoch_k < prev_stoch_d) and
                (curr_stoch_k > curr_stoch_d) and
                (curr_stoch_k < self.stoch_k_overbought)
            )
            
            # Short: Price below filter, StochasticRSI K line crosses D line from above
            short_condition = (
                (self.trade_direction in ['BOTH', 'SHORT']) and
                (curr_close < curr_gc_filter) and
                (prev_stoch_k > prev_stoch_d) and
                (curr_stoch_k < curr_stoch_d) and
                (curr_stoch_k > self.stoch_k_oversold)
            )
            
            # Previous was no position or an opposite position
            no_position_or_opposite = (result.iloc[i-1]['signal'] <= 0 if long_condition else 
                                     result.iloc[i-1]['signal'] >= 0 if short_condition else True)
            
            # Generate entry signals
            if (long_condition or short_condition) and no_position_or_opposite:
                # Set signal value (1 for long, -1 for short)
                signal_value = 1 if long_condition else -1
                result.iloc[i, result.columns.get_loc('signal')] = signal_value
                result.iloc[i, result.columns.get_loc('signal_type')] = SignalType.ENTRY.value
                
                # Calculate stop loss and take profit levels
                if long_condition:
                    stop_loss = curr_close - (curr_atr * self.stop_loss_atr_multiplier)
                    take_profit = curr_close + (curr_atr * self.take_profit_atr_multiplier)
                    direction = "LONG"
                else:  # short_condition
                    stop_loss = curr_close + (curr_atr * self.stop_loss_atr_multiplier)
                    take_profit = curr_close - (curr_atr * self.take_profit_atr_multiplier)
                    direction = "SHORT"
                    
                result.iloc[i, result.columns.get_loc('stop_loss')] = stop_loss
                result.iloc[i, result.columns.get_loc('take_profit')] = take_profit
                
                # Create Signal object
                timestamp = result.index[i]
                
                signal = Signal(
                    timestamp=timestamp,
                    symbol=symbol,
                    signal_type=SignalType.ENTRY,
                    price=curr_close,
                    direction=direction,
                    stop_loss_level=stop_loss,
                    take_profit_level=take_profit,
                    metadata={
                        'gc_filter': curr_gc_filter,
                        'stoch_k': curr_stoch_k,
                        'stoch_d': curr_stoch_d,
                        'atr': curr_atr
                    }
                )
                
                signals.append(signal)
                logger.debug(f"Generated entry signal: {signal}")
                
            # Exit conditions
            elif result.iloc[i-1]['signal'] != 0:  # Previous had a position
                prev_signal = result.iloc[i-1]['signal']
                curr_direction = "LONG" if prev_signal > 0 else "SHORT"
                exit_reason = None
                
                # Check exit conditions
                if curr_direction == "LONG":
                    # Exit long if price crosses below filter line
                    if curr_close < curr_gc_filter:
                        exit_reason = ExitReason.SIGNAL_CHANGE
                    # Or if stochastic RSI gets overbought and turns down
                    elif (prev_stoch_k > self.stoch_k_overbought and 
                          curr_stoch_k < prev_stoch_k and 
                          curr_stoch_k < curr_stoch_d):
                        exit_reason = ExitReason.CUSTOM
                    # Stop loss hit
                    elif curr_close <= result.iloc[i-1]['stop_loss']:
                        exit_reason = ExitReason.STOP_LOSS
                    # Take profit hit
                    elif curr_close >= result.iloc[i-1]['take_profit']:
                        exit_reason = ExitReason.TAKE_PROFIT
                        
                else:  # SHORT
                    # Exit short if price crosses above filter line
                    if curr_close > curr_gc_filter:
                        exit_reason = ExitReason.SIGNAL_CHANGE
                    # Or if stochastic RSI gets oversold and turns up
                    elif (prev_stoch_k < self.stoch_k_oversold and 
                          curr_stoch_k > prev_stoch_k and 
                          curr_stoch_k > curr_stoch_d):
                        exit_reason = ExitReason.CUSTOM
                    # Stop loss hit
                    elif curr_close >= result.iloc[i-1]['stop_loss']:
                        exit_reason = ExitReason.STOP_LOSS
                    # Take profit hit
                    elif curr_close <= result.iloc[i-1]['take_profit']:
                        exit_reason = ExitReason.TAKE_PROFIT
                        
                if exit_reason is not None:
                    result.iloc[i, result.columns.get_loc('signal')] = 0
                    result.iloc[i, result.columns.get_loc('signal_type')] = SignalType.EXIT.value
                    
                    # Create exit Signal object
                    timestamp = result.index[i]
                    
                    signal = Signal(
                        timestamp=timestamp,
                        symbol=symbol,
                        signal_type=SignalType.EXIT,
                        price=curr_close,
                        direction=curr_direction,
                        exit_reason=exit_reason,
                        metadata={
                            'gc_filter': curr_gc_filter,
                            'stoch_k': curr_stoch_k,
                            'stoch_d': curr_stoch_d,
                            'atr': curr_atr
                        }
                    )
                    
                    signals.append(signal)
                    logger.debug(f"Generated exit signal: {signal}")
                    
                else:
                    # Continue with previous position
                    result.iloc[i, result.columns.get_loc('signal')] = prev_signal
                    result.iloc[i, result.columns.get_loc('stop_loss')] = result.iloc[i-1]['stop_loss']
                    result.iloc[i, result.columns.get_loc('take_profit')] = result.iloc[i-1]['take_profit']
            
        # Filter out NaN values for better visualization
        result.dropna(subset=['gc_filter'], inplace=True)
        
        return result, signals
        
    def backtest(self, df: pd.DataFrame, symbol: str) -> Dict[str, Any]:
        """
        Run a backtest of the strategy on historical data.
        
        Args:
            df: DataFrame with price data
            symbol: Trading symbol
            
        Returns:
            Dictionary with backtest results
        """
        # Generate signals
        signals_df, signal_objects = self.generate_signals(df, symbol)
        
        if len(signal_objects) == 0:
            logger.warning(f"No signals generated for {symbol}")
            return {
                "symbol": symbol,
                "total_trades": 0,
                "win_rate": 0.0,
                "profit_factor": 0.0,
                "net_profit": 0.0,
                "max_drawdown": 0.0,
                "sharpe_ratio": 0.0,
                "trades": []
            }
            
        # Prepare for processing trades
        trades = []
        open_position = None
        entry_price = 0.0
        entry_time = None
        position_type = None
        stop_loss = 0.0
        take_profit = 0.0
        
        # Process signals to create trades
        for signal in signal_objects:
            if signal.signal_type == SignalType.ENTRY:
                if open_position is not None:
                    logger.warning(f"Entry signal received while position was still open: {signal}")
                    continue
                    
                # Open new position
                open_position = signal
                entry_price = signal.price
                entry_time = signal.timestamp
                position_type = signal.direction
                stop_loss = signal.stop_loss_level
                take_profit = signal.take_profit_level
                
            elif signal.signal_type == SignalType.EXIT and open_position is not None:
                # Close the position and calculate results
                exit_price = signal.price
                exit_time = signal.timestamp
                
                # Calculate P&L
                if position_type == "LONG":
                    pnl_pct = (exit_price / entry_price) - 1.0
                else:  # SHORT
                    pnl_pct = 1.0 - (exit_price / entry_price)
                    
                # Create trade record
                trade = {
                    "symbol": symbol,
                    "entry_time": entry_time,
                    "exit_time": exit_time,
                    "direction": position_type,
                    "entry_price": entry_price,
                    "exit_price": exit_price,
                    "stop_loss": stop_loss,
                    "take_profit": take_profit,
                    "pnl_pct": pnl_pct,
                    "exit_reason": signal.exit_reason.value if signal.exit_reason else None
                }
                
                trades.append(trade)
                
                # Reset position
                open_position = None
                entry_price = 0.0
                position_type = None
                
        # Calculate backtest metrics
        total_trades = len(trades)
        winning_trades = [t for t in trades if t['pnl_pct'] > 0]
        losing_trades = [t for t in trades if t['pnl_pct'] <= 0]
        
        win_count = len(winning_trades)
        loss_count = len(losing_trades)
        
        # Avoid division by zero
        win_rate = win_count / total_trades if total_trades > 0 else 0.0
        
        # Calculate profit metrics
        total_profit = sum(t['pnl_pct'] for t in winning_trades) if winning_trades else 0.0
        total_loss = sum(abs(t['pnl_pct']) for t in losing_trades) if losing_trades else 0.0
        
        profit_factor = total_profit / total_loss if total_loss > 0 else float('inf') if total_profit > 0 else 0.0
        net_profit = total_profit - total_loss
        
        # Calculate equity curve for drawdown and Sharpe
        equity_curve = [1.0]
        for trade in trades:
            equity_curve.append(equity_curve[-1] * (1.0 + trade['pnl_pct']))
            
        # Calculate max drawdown
        peak = equity_curve[0]
        max_dd = 0.0
        
        for value in equity_curve:
            if value > peak:
                peak = value
            dd = (peak - value) / peak
            max_dd = max(max_dd, dd)
            
        # Calculate Sharpe ratio (simplified, assuming no risk-free rate)
        if len(trades) > 1:
            returns = [trade['pnl_pct'] for trade in trades]
            avg_return = sum(returns) / len(returns)
            std_dev = np.std(returns)
            sharpe = avg_return / std_dev if std_dev > 0 else 0.0
        else:
            sharpe = 0.0
            
        # Create and return backtest results
        results = {
            "symbol": symbol,
            "total_trades": total_trades,
            "win_rate": win_rate,
            "profit_factor": profit_factor,
            "net_profit": net_profit,
            "max_drawdown": max_dd,
            "sharpe_ratio": sharpe,
            "trades": trades
        }
        
        return results