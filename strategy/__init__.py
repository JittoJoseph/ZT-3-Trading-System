"""
Strategy module for ZT-3 Trading System.

This module provides the interface for implementing trading strategies,
as well as the signal generation framework.
"""

import logging
import enum
from datetime import datetime
from typing import Dict, List, Any, Optional, Union
import pandas as pd
import numpy as np

logger = logging.getLogger(__name__)

class SignalType(enum.Enum):
    """Enum for signal types."""
    ENTRY = "ENTRY"
    EXIT = "EXIT"

class ExitReason(enum.Enum):
    """Enum for exit reasons."""
    TAKE_PROFIT = "TAKE_PROFIT"
    TRAILING_STOP = "TRAILING_STOP"
    FILTER_CROSS = "FILTER_CROSS"
    END_OF_DAY = "END_OF_DAY"
    MANUAL = "MANUAL"
    RISK_MANAGER = "RISK_MANAGER"

class Signal:
    """
    Trading signal generated by a strategy.
    
    Represents a buy/sell signal with associated metadata.
    """
    
    def __init__(self, 
                signal_type: SignalType,
                symbol: str,
                price: float,
                timestamp: pd.Timestamp,
                take_profit_level: Optional[float] = None,
                stop_loss_level: Optional[float] = None,
                exit_reason: Optional[ExitReason] = None):
        """
        Initialize a new signal.
        
        Args:
            signal_type: Entry or exit signal
            symbol: Trading symbol
            price: Signal price level
            timestamp: Signal generation time
            take_profit_level: Optional take profit level
            stop_loss_level: Optional stop loss level
            exit_reason: Reason for exit signals
        """
        self.signal_type = signal_type
        self.symbol = symbol
        self.price = price
        self.timestamp = timestamp
        self.take_profit_level = take_profit_level
        self.stop_loss_level = stop_loss_level
        self.exit_reason = exit_reason
        self.id = f"{symbol}_{signal_type.value}_{timestamp.strftime('%Y%m%d%H%M%S')}"
    
    def __str__(self) -> str:
        """String representation of the signal."""
        signal_str = f"{self.signal_type.value} {self.symbol} @ {self.price:.2f}"
        
        if self.take_profit_level:
            signal_str += f", TP: {self.take_profit_level:.2f}"
            
        if self.stop_loss_level:
            signal_str += f", SL: {self.stop_loss_level:.2f}"
            
        if self.exit_reason:
            signal_str += f", Reason: {self.exit_reason.value}"
            
        return signal_str
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert signal to dictionary."""
        return {
            "id": self.id,
            "type": self.signal_type.value,
            "symbol": self.symbol,
            "price": self.price,
            "timestamp": self.timestamp.isoformat(),
            "take_profit_level": self.take_profit_level,
            "stop_loss_level": self.stop_loss_level,
            "exit_reason": self.exit_reason.value if self.exit_reason else None
        }

class Strategy:
    """
    Base class for all trading strategies.
    
    Provides a standard interface for implementing trading strategies
    and generating signals.
    """
    
    def __init__(self, config: Dict[str, Any]):
        """
        Initialize a strategy.
        
        Args:
            config: Strategy configuration dictionary
        """
        self.config = config
        self.name = self.__class__.__name__
        self.params = config.get('strategy', {}).get('params', {})
        
        # Default settings if not specified in config
        self.symbols = [s['ticker'] for s in config.get('symbols', [])]
        
        # Signal tracking to avoid duplicates
        self._last_entry_signals = {}  # {symbol: timestamp}
        self._last_exit_signals = {}   # {symbol: timestamp}
        
        logger.info(f"Initializing strategy: {self.name}")
    
    def process_candle(self, candle_data: pd.DataFrame, symbol: str) -> Optional[Signal]:
        """
        Process new candle data and generate signals if conditions are met.
        
        Args:
            candle_data: DataFrame containing candle data with indicators
            symbol: Trading symbol
            
        Returns:
            Signal if conditions are met, None otherwise
        """
        # This method should be overridden by concrete strategy classes
        raise NotImplementedError("Subclasses must implement process_candle()")
    
    def calculate_take_profit(self, entry_price: float, candle_data: pd.DataFrame) -> float:
        """
        Calculate take profit level based on ATR.
        
        Args:
            entry_price: Entry price
            candle_data: DataFrame containing candle data with indicators
            
        Returns:
            Take profit price level
        """
        # Default implementation using ATR
        atr = candle_data['atr'].iloc[-1]
        atr_multiplier = self.params.get('atr_tp_multiplier', 4.0)
        return entry_price + (atr * atr_multiplier)
    
    def calculate_stop_loss(self, entry_price: float, candle_data: pd.DataFrame) -> float:
        """
        Calculate stop loss level.
        
        Args:
            entry_price: Entry price
            candle_data: DataFrame containing candle data with indicators
            
        Returns:
            Stop loss price level
        """
        # Default implementation - override in subclasses as needed
        # By default, using a percentage of entry price
        stop_percent = self.params.get('stop_loss_percent', 1.5)
        return entry_price * (1 - stop_percent/100)
    
    def is_duplicate_signal(self, signal_type: SignalType, symbol: str, timestamp: pd.Timestamp) -> bool:
        """
        Check if a signal is a duplicate.
        
        Args:
            signal_type: Type of signal
            symbol: Trading symbol
            timestamp: Signal timestamp
            
        Returns:
            True if signal is a duplicate, False otherwise
        """
        if signal_type == SignalType.ENTRY:
            if symbol in self._last_entry_signals:
                last_ts = self._last_entry_signals[symbol]
                # Consider as duplicate if within same candle
                if timestamp.floor('5min') == last_ts.floor('5min'):
                    return True
            self._last_entry_signals[symbol] = timestamp
        else:  # EXIT
            if symbol in self._last_exit_signals:
                last_ts = self._last_exit_signals[symbol]
                # Consider as duplicate if within same candle
                if timestamp.floor('5min') == last_ts.floor('5min'):
                    return True
            self._last_exit_signals[symbol] = timestamp
        
        return False