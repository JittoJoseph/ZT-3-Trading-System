"""
Strategy module for ZT-3 Trading System.

This module provides the interface for implementing trading strategies,
as well as the signal generation framework.
"""

import logging
import enum
from datetime import datetime
from typing import Dict, List, Any, Optional, Union
import pandas as pd
import numpy as np

logger = logging.getLogger(__name__)

class SignalType(enum.Enum):
    """Enum for signal types."""
    ENTRY = "ENTRY"
    EXIT = "EXIT"

class ExitReason(enum.Enum):
    """Enum for exit reasons."""
    TAKE_PROFIT = "TAKE_PROFIT"
    PARTIAL_TAKE_PROFIT = "PARTIAL_TAKE_PROFIT" # Added
    STOP_LOSS = "STOP_LOSS" # Added for clarity, was implicit before
    TRAILING_STOP = "TRAILING_STOP"
    FILTER_CROSS = "FILTER_CROSS" # Will be EMA_CROSS for new strategy
    END_OF_DAY = "END_OF_DAY" # Less relevant for daily strategy
    MANUAL = "MANUAL"
    RISK_MANAGER = "RISK_MANAGER"
    EMA_CROSS = "EMA_CROSS" # Added for new strategy

class Signal:
    """
    Trading signal generated by a strategy.
    
    Represents a buy/sell signal with associated metadata.
    """
    
    def __init__(self, 
                signal_type: SignalType,
                symbol: str,
                price: float,
                timestamp: pd.Timestamp,
                take_profit_level: Optional[float] = None,
                stop_loss_level: Optional[float] = None,
                exit_reason: Optional[ExitReason] = None):
        """
        Initialize a new signal.
        
        Args:
            signal_type: Entry or exit signal
            symbol: Trading symbol
            price: Signal price level
            timestamp: Signal generation time
            take_profit_level: Optional take profit level
            stop_loss_level: Optional stop loss level
            exit_reason: Reason for exit signals
        """
        self.signal_type = signal_type
        self.symbol = symbol
        self.price = price
        self.timestamp = timestamp
        self.take_profit_level = take_profit_level
        self.stop_loss_level = stop_loss_level
        self.exit_reason = exit_reason
        self.id = f"{symbol}_{signal_type.value}_{timestamp.strftime('%Y%m%d%H%M%S')}"
    
    def __str__(self) -> str:
        """String representation of the signal."""
        signal_str = f"{self.signal_type.value} {self.symbol} @ {self.price:.2f}"
        
        if self.take_profit_level:
            signal_str += f", TP: {self.take_profit_level:.2f}"
            
        if self.stop_loss_level:
            signal_str += f", SL: {self.stop_loss_level:.2f}"
            
        if self.exit_reason:
            signal_str += f", Reason: {self.exit_reason.value}"
            
        return signal_str
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert signal to dictionary."""
        return {
            "id": self.id,
            "type": self.signal_type.value,
            "symbol": self.symbol,
            "price": self.price,
            "timestamp": self.timestamp.isoformat(),
            "take_profit_level": self.take_profit_level,
            "stop_loss_level": self.stop_loss_level,
            "exit_reason": self.exit_reason.value if self.exit_reason else None
        }

class Strategy:
    """
    Base class for all trading strategies.
    
    Provides a standard interface for implementing trading strategies
    and generating signals. Strategy parameters should be hardcoded 
    in each strategy implementation rather than taken from config.
    """
    
    def __init__(self, config: Dict[str, Any]):
        """
        Initialize a strategy.
        
        Args:
            config: System configuration dictionary (not for strategy parameters)
        """
        self.config = config
        self.name = self.__class__.__name__
        
        # Default settings
        self.symbols = [s['ticker'] for s in config.get('symbols', [])]
        
        # Signal tracking to avoid duplicates
        self._last_entry_signals = {}  # {symbol: timestamp}
        self._last_exit_signals = {}   # {symbol: timestamp}
        
        logger.info(f"Initializing strategy: {self.name}")
    
    def process_candle(self, candle_data: pd.DataFrame, symbol: str) -> Optional[Signal]:
        """
        Process new candle data and generate signals if conditions are met.
        
        Args:
            candle_data: DataFrame containing candle data with indicators
            symbol: Trading symbol
            
        Returns:
            Signal if conditions are met, None otherwise
        """
        # This method should be overridden by concrete strategy classes
        raise NotImplementedError("Subclasses must implement process_candle()")
    
    def prepare_data(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Prepare data by calculating all necessary indicators.
        
        Args:
            df: DataFrame with raw OHLCV data
            
        Returns:
            DataFrame with all indicators added
        """
        # This method should be overridden by concrete strategy classes
        raise NotImplementedError("Subclasses must implement prepare_data()")
    
    def calculate_take_profit(self, entry_price: float, candle_data: pd.DataFrame) -> float:
        """
        Calculate take profit level.
        
        Args:
            entry_price: Entry price
            candle_data: DataFrame containing candle data with indicators
            
        Returns:
            Take profit price level
        """
        # This method should be overridden by concrete strategy classes
        raise NotImplementedError("Subclasses must implement calculate_take_profit()")
    
    def is_duplicate_signal(self, signal_type: SignalType, symbol: str, timestamp: pd.Timestamp) -> bool:
        """
        Check if a signal is a duplicate within the same candle interval (e.g., hour).

        Args:
            signal_type: Type of signal
            symbol: Trading symbol
            timestamp: Signal timestamp

        Returns:
            True if signal is a duplicate, False otherwise
        """
        last_signals_map = self._last_entry_signals if signal_type == SignalType.ENTRY else self._last_exit_signals

        if symbol in last_signals_map:
            last_ts = last_signals_map[symbol]
            # Consider as duplicate if within the same hour bar
            # Use floor('h') for hourly interval (replaced 'H')
            if timestamp.floor('h') == last_ts.floor('h'):
                return True

        # Update the last signal timestamp for this type and symbol
        last_signals_map[symbol] = timestamp
        return False

    def generate_signals(self, df: pd.DataFrame, symbol: str) -> List[Signal]:
        """
        Generate all trading signals for a historical dataset.
        
        This is primarily used for backtesting.
        
        Args:
            df: DataFrame with price data (should contain OHLCV data)
            symbol: Trading symbol
            
        Returns:
            List of Signal objects
        """
        # This can be implemented by concrete strategy classes if needed
        # Otherwise use this default implementation that processes each candle
        signals = []
        
        # Process each candle and accumulate signals
        for i in range(1, len(df)):
            # Create a DataFrame with data up to the current candle
            data_slice = df.iloc[:i+1]
            
            # Process the candle
            signal = self.process_candle(data_slice, symbol)
            
            # Add signal to list if generated
            if signal:
                signals.append(signal)
                
        return signals